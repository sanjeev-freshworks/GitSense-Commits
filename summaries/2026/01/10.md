# Activity Summary for 1/10/2026

## 1:52:53 PM
The file `Untitled-3`, timestamped 1/9/2026, 2:05:46 PM, details development notes and open questions for two primary features: Notification Burst detection and an App Review and Rating Prompt.

**Notification Burst Feature:**
This section outlines the logic for identifying and managing "burst" notifications, defined as `C` notifications received within `T` time.
*   **Core Logic:** It proposes using a deque (`back[]front`) to store notification timestamps. New notifications are added to the front, and older ones are removed from the back once the deque reaches capacity `C`.
*   **Special Notification:** A `bool isSpecialNotificationShown` flag is used to ensure a special notification is displayed only once per burst, with subsequent burst notifications either discarded or handled without re-showing the special notification.
*   **Conditions:** The logic details how to differentiate between a normal notification, a burst notification (when `current_timestamp - oldest_timestamp < T`), and a non-burst notification if the time threshold `T` is exceeded. When `T` is exceeded, the deque is cleared, and `isSpecialNotificationShown` is reset.
*   **Examples:** Concrete values like `T = 15` and `C = 3` are provided with timestamp examples to illustrate the burst detection mechanism.
*   **Follow-up/Suggestions:** A comprehensive list of "Todo / suggestions" indicates areas for further development, including: controlling special notification frequency and position, handling notification IDs and icons, testing for double account IDs, automating notifications, refining deque reset logic, injecting `gson`, displaying account names, adding click events, utilizing notification counts, and adding getters/setters in `ListNotificationViewModel`. A suggestion to rename `NotificationBurstItem` to `SafeNotificationItem` is also noted.

**App Review and Rating Prompt:**
This section focuses on the behavior and implementation challenges of an app review prompt.
*   **Prompt Logic:** The prompt's display mechanism dictates that once shown, a counter should be reset for 90 days, during which no further increments occur. After this 90-day period, the counter resumes incrementing. If the prompt has not been shown, the counter continuously increments.
*   **TODOs:** Key tasks include testing the current app review code, refactoring `AppReviewManager` and `AppStore`, ensuring the prompt shows immediately on achievement of logic, preventing increment for browser cases in solution articles, and addressing "seen" events.
*   **Questions:** Several "Unanswered" questions cover architectural decisions (separate module vs. core module), fixing duplicate API calls (`update tasks api`), and specific use cases like ticket management and "different" detection. "Answered" questions clarify aspects like asset validity for tickets, agent's ability to create tickets, data loss on uninstall (acceptable), separate PR for refactoring (yes), detecting "oncall" users (not needed), using shared preferences (no account-wise counts), and moving prompt logic to `AppReviewManager`.

**Other Minor Mentions:**
*   A brief note about "MDM Browser Config - handle rotation" is present.
*   A pending commit to "Replace png with svg" is mentioned.

**Patterns and Recurring Elements:**
*   **Active Development & Grooming:** The log reads like a detailed grooming session or ongoing development notes, with clear feature descriptions followed by extensive lists of "Todo / suggestions" and "Questions," indicating an iterative development process.
*   **User Experience Focus:** Both main features (notifications and app review) directly address user interaction and experience within the application.
*   **State Management:** There's a strong emphasis on managing state through flags (`isSpecialNotificationShown`), data structures (deque), and explicit reset conditions.
*   **Time-Sensitive Logic:** Both features heavily rely on time-based calculations (burst within `T` time, app review prompt cooldown of 90 days).
*   **Code Quality & Architecture Concerns:** Discussions around refactoring, module structure, and dependency injection suggest an ongoing effort to maintain a robust and scalable codebase.