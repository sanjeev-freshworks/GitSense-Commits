# Activity Summary for 1/15/2026

## 8:45:06 AM
The file `Untitled-3`, last modified on `1/9/2026, 2:05:46 PM`, primarily outlines the logic and associated tasks for a notification burst detection system, alongside notes on an app review and rating prompt, and various development questions.

**Notification Burst Detection:**
This section details a system to detect "burst" notifications, defined as `C` notifications received within `T` time. It uses a deque (`back[]front`) to store notification timestamps.
*   **Logic:**
    *   New notifications are pushed to the front of the deque.
    *   If the deque length reaches `C`, the system compares the timestamp of the incoming notification (`T_new`) with the oldest notification in the deque (`T_old`).
    *   If `T_new - T_old < T`, it's considered a burst. A `isSpecialNotificationShown` flag is used to ensure the special notification is shown only once per burst, otherwise, subsequent burst notifications are discarded. The deque then pops the oldest and pushes the new notification.
    *   If `T_new - T_old >= T`, the time threshold is exceeded, it's not a burst. The deque is cleared, the `isSpecialNotificationShown` flag is reset, and only the new notification is pushed.
*   **Examples:** Concrete examples are provided with `T = 15` and `C = 3` to illustrate scenarios of burst detection and non-detection.
*   **Todos/Suggestions:** A comprehensive list of follow-up tasks includes:
    *   Refining special notification display (showing multiple times, ID, position, icon, click events).
    *   Testing for double account IDs and automating notifications.
    *   Replacing `prevNotificationTime` with a list, working on deque reset logic.
    *   Injecting Gson into `NotificationBurstConverter`.
    *   Adding setters/getters for `shouldShowSpecialNotification` and `accountId` in `ListNotificationViewModel`.
    *   Considering renaming `NotificationBurstItem` to `SafeNotificationItem`.
    *   Mention of a branch replacing PNGs with SVGs, and an unpushed commit.

**App Review and Rating Prompt:**
This part describes the logic for triggering an app review prompt.
*   **Conditions:**
    *   When the prompt is shown, a counter should reset and not increment for the next 90 days.
    *   After the 90-day period ends, incrementing resumes.
    *   If the prompt has not been shown, the counter continues to increment.
*   **Todos:** Tasks include testing the existing app review code and refactoring `AppReviewManager` and `AppStore`.
*   **MDM Browser Config:** A brief note on handling rotation.

**General Development Questions:**
The log includes a section of answered and unanswered questions covering various development and architectural aspects:
*   **Unanswered:** Whether a separate module is needed for a feature, and why an update tasks API is called twice.
*   **Answered:** Confirms asset additions and ticket closing are valid for changes, agents can create tickets, no need to detect "different" states, data loss on uninstall is acceptable, refactoring should be a separate PR, on-call status doesn't need to be recognized (just increment on `ShiftEventActivity` open), preference for persona-independent, shared preferences over account-wise counts, and immediate display of prompts when logic is achieved, with an exception for solution articles in browser cases and for "seen" events.

**Patterns and Recurring Elements:**
*   The log consistently uses a bulleted format for to-do items and questions.
*   There's a clear pattern of presenting a core logic (e.g., notification burst) followed by concrete examples, detailed to-do lists, and open questions related to implementation and design.
*   The use of `*-` for immediate suggestions/todos and `##` for feature-specific todos is consistent.
*   A strong emphasis is placed on user experience features like special notifications and app review prompts, along with their underlying logic and associated development tasks.