# Activity Summary for 1/15/2026

## 8:45:06 AM
The file `Untitled-3`, last modified on `1/9/2026, 2:05:46 PM`, primarily outlines the logic and associated tasks for a notification burst detection system, alongside notes on an app review and rating prompt, and various development questions.

**Notification Burst Detection:**
This section details a system to detect "burst" notifications, defined as `C` notifications received within `T` time. It uses a deque (`back[]front`) to store notification timestamps.
*   **Logic:**
    *   New notifications are pushed to the front of the deque.
    *   If the deque length reaches `C`, the system compares the timestamp of the incoming notification (`T_new`) with the oldest notification in the deque (`T_old`).
    *   If `T_new - T_old < T`, it's considered a burst. A `isSpecialNotificationShown` flag is used to ensure the special notification is shown only once per burst, otherwise, subsequent burst notifications are discarded. The deque then pops the oldest and pushes the new notification.
    *   If `T_new - T_old >= T`, the time threshold is exceeded, it's not a burst. The deque is cleared, the `isSpecialNotificationShown` flag is reset, and only the new notification is pushed.
*   **Examples:** Concrete examples are provided with `T = 15` and `C = 3` to illustrate scenarios of burst detection and non-detection.
*   **Todos/Suggestions:** A comprehensive list of follow-up tasks includes:
    *   Refining special notification display (showing multiple times, ID, position, icon, click events).
    *   Testing for double account IDs and automating notifications.
    *   Replacing `prevNotificationTime` with a list, working on deque reset logic.
    *   Injecting Gson into `NotificationBurstConverter`.
    *   Adding setters/getters for `shouldShowSpecialNotification` and `accountId` in `ListNotificationViewModel`.
    *   Considering renaming `NotificationBurstItem` to `SafeNotificationItem`.
    *   Mention of a branch replacing PNGs with SVGs, and an unpushed commit.

**App Review and Rating Prompt:**
This part describes the logic for triggering an app review prompt.
*   **Conditions:**
    *   When the prompt is shown, a counter should reset and not increment for the next 90 days.
    *   After the 90-day period ends, incrementing resumes.
    *   If the prompt has not been shown, the counter continues to increment.
*   **Todos:** Tasks include testing the existing app review code and refactoring `AppReviewManager` and `AppStore`.
*   **MDM Browser Config:** A brief note on handling rotation.

**General Development Questions:**
The log includes a section of answered and unanswered questions covering various development and architectural aspects:
*   **Unanswered:** Whether a separate module is needed for a feature, and why an update tasks API is called twice.
*   **Answered:** Confirms asset additions and ticket closing are valid for changes, agents can create tickets, no need to detect "different" states, data loss on uninstall is acceptable, refactoring should be a separate PR, on-call status doesn't need to be recognized (just increment on `ShiftEventActivity` open), preference for persona-independent, shared preferences over account-wise counts, and immediate display of prompts when logic is achieved, with an exception for solution articles in browser cases and for "seen" events.

**Patterns and Recurring Elements:**
*   The log consistently uses a bulleted format for to-do items and questions.
*   There's a clear pattern of presenting a core logic (e.g., notification burst) followed by concrete examples, detailed to-do lists, and open questions related to implementation and design.
*   The use of `*-` for immediate suggestions/todos and `##` for feature-specific todos is consistent.
*   A strong emphasis is placed on user experience features like special notifications and app review prompts, along with their underlying logic and associated development tasks.

## 1:45:05 PM
The provided log primarily details changes and considerations for the file `Untitled-3`, with a timestamp of 1/9/2026, 2:05:46 PM.

The central theme revolves around implementing and refining a **Notification Burst** mechanism. This involves:

*   **Logic Definition**: A detailed description of a system using a deque (doubly-ended queue) to track recent notifications. It defines conditions (`T` for time threshold, `C` for notification count) to identify a "burst" of notifications.
    *   Notifications (`T0`, `T1`, `T2`, etc.) are pushed to the front of the deque.
    *   When the deque reaches `C` length, a new notification is compared with the oldest (`T3 - T0 < T`).
    *   If a burst is detected, a `isSpecialNotificationShown` flag is used to manage showing a special notification or discarding subsequent ones within the burst.
    *   If the time threshold (`T`) is exceeded, the deque is cleared, `isSpecialNotificationShown` is reset, and the new notification is considered a normal one.
    *   Examples are provided with specific time values and expected outcomes (e.g., `T=15`, `C=3`).
*   **TODOs/Suggestions for Notification Burst**: A list of future enhancements and points of consideration, including:
    *   Allowing special notifications to show more than once.
    *   Managing notification IDs and positioning (e.g., `setSortKey`).
    *   Testing with double account IDs and automating notifications.
    *   Refactoring the deque logic (replacing `prevNotificationTime` with a list, resetting the deque).
    *   Checking for `gson` injection.
    *   Improving special notification UI (title with account name, icon, click events).
    *   Adding setters/getters for `shouldShowSpecialNotification` and `accountId` in `ListNotificationViewModel`.
    *   Considering renaming `NotificationBurstItem` to `SafeNotificationItem`.

Beyond notification bursting, the log also mentions other development areas:

*   **Branch/Commit Notes**: References to unpushed commits like "Replace png with svg" and updating existing special notifications.
*   **MDM Browser Config**: A brief note on handling rotation.
*   **App Review and Rating Prompt**:
    *   **Logic**: Details how the prompt should be managed, including resetting a counter when shown, a 90-day cooldown period, and incrementing behavior.
    *   **TODOs**: Testing current implementation, refactoring `AppReviewManager` and `AppStore`.
    *   **Questions**: A comprehensive list of answered and unanswered questions covering architectural decisions (modules), API call optimizations, asset validity, ticket creation, data persistence on uninstall, PR strategy, user on-call detection, data storage (shared preferences), and specific conditions for showing the prompt (immediate display, ignoring for browser cases, "seen" events).

**Patterns and Recurring Elements**:

*   **Detailed Algorithmic Descriptions**: The document frequently uses a step-by-step, almost pseudo-code-like approach to describe logic (e.g., how the deque operates, how the app review prompt counter behaves).
*   **Clear Problem/Solution Formulation**: For both notification bursts and app review, a problem is outlined, a proposed solution/logic is detailed, and then a list of open questions or future improvements (TODOs) follows.
*   **Use of Constants and Flags**: The `T` and `C` constants for notification burst thresholds and the `isSpecialNotificationShown` boolean flag are central to the notification logic and are referred to repeatedly.
*   **Focus on Edge Cases and Refinements**: Many TODOs and questions address potential edge cases, user experience improvements, and technical refinements of the implemented logic.